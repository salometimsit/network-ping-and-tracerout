#include <stdio.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp6.h>
#include <poll.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <unistd.h>
#include <getopt.h>
#include <math.h>
#include "pingg.h"

// Constants
#define MAX_REQUESTS 10
#define TIMEOUT 1000  // Timeout in milliseconds
#define BUFFER_SIZE 1024
#define SLEEP_TIME 1  // Delay between pings in seconds
#define MAX_RETRY 3

// Function prototypes
unsigned short calculate_checksum(void *b, int len);
void display_results(float *result, char *addr);
double calculate_std(float *arr, int size, float mean);

// Global variables
int sending_pings = 0;
int recive_pings = 0;
int rtt_count = 0;
float *rtts = NULL;

int main(int argc, char *argv[]) {
    if (argc < 5) {
        fprintf(stderr, "Usage: %s -a <address> -t <type> [-c <count>] [-f]\n", argv[0]);
        return 1;
    }

    int count = MAX_REQUESTS;  // Default number of pings
    int flood = 0;             // Flood mode flag
    int ip_v = 0;              // IP version (4 for IPv4, 6 for IPv6)
    char *address = NULL;      // Target address
    int opt;

    // Parse command-line arguments
    while ((opt = getopt(argc, argv, "a:t:c:f")) != -1) {
        switch (opt) {
            case 'a':
                address = optarg;
                break;
            case 't':
                ip_v = atoi(optarg);
                if (ip_v != 4 && ip_v != 6) {
                    fprintf(stderr, "Error: Invalid type '%s'. Use 4 for IPv4 or 6 for IPv6.\n", optarg);
                    return 1;
                }
                break;
            case 'c':
                count = atoi(optarg);
                break;
            case 'f':
                flood = 1;
                break;
            default:
                fprintf(stderr, "Usage: %s -a <address> -t <type> [-c <count>] [-f]\n", argv[0]);
                return 1;
        }
    }

    if (ip_v == 0) {
        fprintf(stderr, "Error: IP version is required (use -t flag with 4 for IPv4 or 6 for IPv6).\n");
        return 1;
    }

    if (address == NULL) {
        fprintf(stderr, "Error: IP address is required (use -a flag).\n");
        return 1;
    }

    rtts = (float *)malloc(count * sizeof(float));
    if (rtts == NULL) {
        perror("malloc");
        return 1;
    }

    // Set up destination address
    struct sockaddr_storage destination_address;
    memset(&destination_address, 0, sizeof(destination_address));

    if (ip_v == 4) {
        if (inet_pton(AF_INET, address, &((struct sockaddr_in *)&destination_address)->sin_addr) <= 0) {
            fprintf(stderr, "Error: \"%s\" is not a valid IPv4 address\n", address);
            return 1;
        }
        ((struct sockaddr_in *)&destination_address)->sin_family = AF_INET;
    } else {
        if (inet_pton(AF_INET6, address, &((struct sockaddr_in6 *)&destination_address)->sin6_addr) <= 0) {
            fprintf(stderr, "Error: \"%s\" is not a valid IPv6 address\n", address);
            return 1;
        }
        ((struct sockaddr_in6 *)&destination_address)->sin6_family = AF_INET6;
    }

    // Create socket
    int sock = (ip_v == 4) ?
               socket(AF_INET, SOCK_RAW, IPPROTO_ICMP) :
               socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);

    if (sock < 0) {
        perror("socket");
        if (errno == EACCES || errno == EPERM)
            fprintf(stderr, "You need to run the program with sudo.\n");
        return 1;
    }

    char buffer[BUFFER_SIZE] = {0};
    char *msg = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$^&*()_+{}|:<>?~`-=[]',.";
    int payload_size = strlen(msg) + 1;
    int retries = 0;
    int seq = 0;

    struct pollfd fds[1];
    fds[0].fd = sock;
    fds[0].events = POLLIN;

    fprintf(stdout, "PING %s with %d bytes of data:\n", address, payload_size);

    // Main ping loop
    while (count-- > 0) {
        memset(buffer, 0, sizeof(buffer));

        if (ip_v == 4) {
            struct icmphdr icmp_header;
            icmp_header.type = ICMP_ECHO;
            icmp_header.code = 0;
            icmp_header.un.echo.id = htons(getpid());
            icmp_header.un.echo.sequence = htons(seq++);
            icmp_header.checksum = 0;

            memcpy(buffer, &icmp_header, sizeof(icmp_header));
            memcpy(buffer + sizeof(icmp_header), msg, payload_size);
            ((struct icmphdr *)buffer)->checksum = calculate_checksum(buffer, sizeof(icmp_header) + payload_size);
        } else {
            struct icmp6_hdr icmp6_header;
            icmp6_header.icmp6_type = ICMP6_ECHO_REQUEST;
            icmp6_header.icmp6_code = 0;
            icmp6_header.icmp6_id = htons(getpid());
            icmp6_header.icmp6_seq = htons(seq++);
            icmp6_header.icmp6_cksum = 0;

            memcpy(buffer, &icmp6_header, sizeof(icmp6_header));
            memcpy(buffer + sizeof(icmp6_header), msg, payload_size);
        }

        struct timeval start, end;
        gettimeofday(&start, NULL);

        if (ip_v == 4) {
            if (sendto(sock, buffer, sizeof(struct icmphdr) + payload_size, 0, 
                       (struct sockaddr *)&destination_address, sizeof(struct sockaddr_in)) <= 0) {
                perror("sendto");
                close(sock);
                return 1;
            }
        } else {
            if (sendto(sock, buffer, sizeof(struct icmp6_hdr) + payload_size, 0, 
                       (struct sockaddr *)&destination_address, sizeof(struct sockaddr_in6)) <= 0) {
                perror("sendto");
                close(sock);
                return 1;
            }
        }
        sending_pings++;

        int ret = poll(fds, 1, TIMEOUT);
        if (ret == 0) {
            fprintf(stderr, "Request timeout for icmp_seq %d\n", seq);
            continue;
        } else if (ret < 0) {
            perror("poll");
            close(sock);
            return 1;
        }

        if (fds[0].revents & POLLIN) {
            struct sockaddr_storage source_address;
            socklen_t addr_len = sizeof(source_address);
            memset(buffer, 0, sizeof(buffer));

            if (recvfrom(sock, buffer, sizeof(buffer), 0, 
                         (struct sockaddr *)&source_address, &addr_len) <= 0) {
                perror("recvfrom");
                close(sock);
                return 1;
            }

            gettimeofday(&end, NULL);

            if (ip_v == 4) {
                struct iphdr *ip_header = (struct iphdr *)buffer;
                struct icmphdr *icmp_header = (struct icmphdr *)(buffer + ip_header->ihl * 4);

                if (icmp_header->type == ICMP_ECHOREPLY) {
                    float rtt = ((end.tv_sec - start.tv_sec) * 1000.0) + ((end.tv_usec - start.tv_usec) / 1000.0);
                    fprintf(stdout, "%ld bytes from %s: icmp_seq=%d ttl=%d time=%.2f ms\n",
                            (ntohs(ip_header->tot_len) - ip_header->ihl * 4 - sizeof(struct icmphdr)),
                            inet_ntoa(((struct sockaddr_in *)&source_address)->sin_addr),
                            ntohs(icmp_header->un.echo.sequence),
                            ip_header->ttl, rtt);
                    rtts[rtt_count++] = rtt;
                    recive_pings++;
                }
            } else {
                struct icmp6_hdr *icmp6_header = (struct icmp6_hdr *)buffer;

                if (icmp6_header->icmp6_type == ICMP6_ECHO_REPLY) {
                    float rtt = ((end.tv_sec - start.tv_sec) * 1000.0) + ((end.tv_usec - start.tv_usec) / 1000.0);
                    char addr_str[INET6_ADDRSTRLEN];
                    inet_ntop(AF_INET6, &((struct sockaddr_in6 *)&source_address)->sin6_addr, addr_str, sizeof(addr_str));
                    fprintf(stdout, "%d bytes from %s: icmp_seq=%d time=%.2f ms\n",
                            payload_size, addr_str, ntohs(icmp6_header->icmp6_seq), rtt);
                    rtts[rtt_count++] = rtt;
                    recive_pings++;
                }
            }
        }

        if (flood) {
            usleep(1000);  // Minimal delay for flood mode
        } else {
            sleep(SLEEP_TIME);
        }
    }

    close(sock);
    display_results(rtts, address);
    free(rtts);
    return 0;
}

// Calculate checksum for ICMP packets
unsigned short calculate_checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    while (len > 1) {
        sum += *buf++;
        len -= 2;
    }
    if (len == 1)
        sum += *(unsigned char *)buf;
    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;
    return result;
}

// Display ping statistics
void display_results(float *result, char *addr) {
    if (rtt_count == 0) {
        printf("No packets received.\n");
        return;
    }

    float min = result[0], max = result[0], sum = result[0];
    for (int i = 1; i < rtt_count; i++) {
        if (result[i] < min) min = result[i];
        if (result[i] > max) max = result[i];
        sum += result[i];
    }
    float avg = sum / rtt_count;
    double std_dev = calculate_std(result, rtt_count, avg);

    printf("--- %s ping statistics ---\n", addr);
    printf("%d packets transmitted, %d received, %.2f%% packet loss\n",
           sending_pings, recive_pings, 100.0 * (sending_pings - recive_pings) / sending_pings);
    printf("rtt min/avg/max/stddev = %.2f/%.2f/%.2f/%.2f ms\n", min, avg, max, std_dev);
}

// Calculate standard deviation
double calculate_std(float *arr, int size, float mean) {
    double sum_of_squares = 0.0;
    for (int i = 0; i < size; i++) {
        sum_of_squares += (arr[i] - mean) * (arr[i] - mean);
    }
    return sqrt(sum_of_squares / size);
}
